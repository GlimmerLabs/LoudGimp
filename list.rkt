#lang racket
(require gigls/guard)
(provide (all-defined-out))


;;; Procedure:
;;;   foreach!
;;; Parameters:
;;;   proc!, a unary procedure called only for its side effects
;;;   lst, a list
;;; Purpose:
;;;   To call proc! for each element of lst.
;;; Produces:
;;;   [Nothing, called for the side effect]
;;; Preconditions:
;;;   proc! can be applied to each element of lst.
;;; Postconditions:
;;;   For each element, x, of lst, (proc! x) has been called.
(define/contract foreach! 
  (-> (-> any/c void) list? void)
  (lambda (proc! lst)
    (cond
      ((null? lst)
       (void))
      (else
       (proc! (car lst))
       (foreach! proc! (cdr lst))))))

; [From iascm/list/list-drop.scm]

;;; Procedure:
;;;   list-drop
;;; Parameters:
;;;   lst, a list
;;;   n, a non-negative integer
;;; Purpose:
;;;   Builds a new list consisting by removing the first n elements of lst.
;;; Produces:
;;;   newlst, a list
;;; Preconditions:
;;;   (length lst) >= n
;;; Postconditions:
;;;   (length newlst) = (length lst) - n
;;;   For each i, 0 <= i < (length newlst)
;;;     (list-ref newlst i) = (list-ref lst (+ n i))
(define/contract list-drop
  (-> list? (and/c integer? positive?) list?)
  (lambda (lst n)
    (cond
      ((zero? n)
       lst)
      ((null? lst)
       null)
      (else
       (list-drop (cdr lst) (- n 1))))))

;(define list-drop
;  (lambda (lst n)
;    (cond
;      ((not (list? lst))
;       (error/parameter-type 'list-drop 1 'list (list lst n)))
;      ((or (not (integer? n)) (negative? n))
;       (error/parameter-type 'list-drop 2 'non-negative-integer (list lst n)))
;      ((< (length lst) n)
;       (error/parameter-type 'list-drop 1 'list-of-length-at-least-n (list lst n)))
;      (else
;       (_list-drop lst n)))))

; [From iascm/list/list-foreach.scm]


;;; Procedure:
;;;   list-foreach!
;;; Parameters:
;;;   lst, a list
;;;   proc!, a unary procedure called only for its side effects
;;; Purpose:
;;;   To call proc! for each element of lst.
;;; Produces:
;;;   [Nothing; called for the side effect]
;;; Preconditions:
;;;   proc! can be applied ot each element of x.
;;; Postconditions:
;;;   For each element x of lst, (proc! x) has been called.
(define/contract list-foreach! 
  (-> list? (-> any/c void) void)
  (lambda (lst proc!)
    (cond 
      ((null? lst)
       (void))
      (else
       (proc! (car lst))
       (list-foreach! (cdr lst) proc!)))))

; [From iascm/list/list-filter-out.scm]

;;; Procedure:
;;;   list-filter-out
;;; Parameters:
;;;   lst, a list of values
;;;   pred?, a unary predicate
;;; Purpose:
;;;   Remove all the values in lst for which pred? holds.
;;; Produces:
;;;   filtered, a list.
;;; Preconditions:
;;;   pred? can be applied to each value in lsts.
;;; Postconditions:
;;;   Every element of filtered appears in lst and in the same order.
;;;   If (not (pred? (list-ref lst i))) holds for some value in
;;;     lst, then (list-ref lst i) appears in filtered.
(define/contract list-filter-out
  (-> list? (-> any/c boolean?) list?)
  (lambda (pred? lst)
    (cond
      ((null? lst)
       null)
      ((pred? (car lst))
       (list-filter-out (cdr lst) pred?))
      (else
       (cons (car lst) (list-filter-out (cdr lst) pred?))))))

; [From iascm/list/list-index.scm]

;;; Procedure:
;;;   list-index
;;; Parameters:
;;;   lst, a list
;;;   val, a Scheme value
;;; Purpose:
;;;   Get the index of val in lst
;;; Produces:
;;;   index, a non-negative integer (or #f)
;;; Preconditions:
;;;   [No additional]
;;; Postconditions:
;;;   If there is an i s.t.
;;;     (list-ref lst i) = val
;;;     then index is an integer.
;;;   Otherwise, index is #f
;;;   If index is an integer
;;;   (list-ref lst index) = val
(define/contract list-index
  (-> list? any/c (or/c (and/c integer? positive?) #f))
  (lambda (lst val)
    (let kernel ((remaining lst)
                 (position 0))
      (cond
        ((null? remaining) 
        #f)
        ((not (pair? remaining))
         (error/parameter-type 'list-index 1 'list (list lst val)))
        ((equal? (car remaining) val)
         position)
        (else
         (kernel (cdr remaining) (+ position 1)))))))

;(define list-index _list-index)

; [From iascm/list/list-last.scm]

;;; Procedure:
;;;   list-last
;;; Parameters:
;;;   lst, a list
;;; Purpose:
;;;   Get the last element in lst
;;; Produces:
;;;   last, a value
;;; Preconditions:
;;;   (length lst) > 0
;;; Postconditions:
;;;   (list-ref lst (- (length lst) 1)) = last
(define/contract list-last
  (-> list? any/c)
  (lambda (lst)
    (if (null? (cdr lst))
        (car lst)
        (list-last (cdr lst)))))

; [From iascm/list/list-random.scm]

;;; Procedure:
;;;   list-random
;;; Parameters:
;;;   n, a non-negative integer
;;;   generate-random-value, a zero-ary function (aka "a thunk")
;;; Purpose:
;;;   Build an unpredictable list of n elements.
;;; Produces:
;;;   values, a list
;;; Preconditions:
;;;   It is difficult to predict the value generated by generate-random-value.
;;; Postconditions:
;;;   (length values) = n
;;;   Each value in values was generated by (generate-random-value)
;(define list-random
;  (lambda (n generate-random-value)
;    (cond
;      ((not (integer? n))
;       (error "list-random: Expects <integer> for parameter 1, given" n))
;      ((negative? n)
;       (error "list-random: Expects <positive integer> for parameter 1, given"
;              n))
;      (else
;       (_list-random n generate-random-value)))))

(define/contract list-random
  (-> (and/c integer? positive?) (-> any/c) list?)
  (lambda (n generate-random-value)
    (if (zero? n)
        null
        (cons (generate-random-value)
              (list-random (- n 1) generate-random-value)))))

; [From iascm/list/list-random-element.scm]

;;; Procedure:
;;;   list-random-element
;;; Parameters:
;;;   values, a list
;;; Purpose:
;;;   Randomly select an element of values.
;;; Produces:
;;;   value, a value
;;; Preconditions:
;;;   values is nonempty.
;;; Postconditions:
;;;   value is an element of values.
;;;   value is equally likely to be any element of values.
(define/contract list-random-element
  (-> list? any/c)
  (lambda (values)
    (list-ref values (random (length values)))))

; [From iascm/list/list-select.scm]

;;; Procedure:
;;;   list-select
;;; Parameters:
;;;   lst, a list of values
;;;   pred?, a unary predicate
;;; Purpose:
;;;   Select all the values in lst for which pred? holds.
;;; Produces:
;;;   selected, a list.
;;; Preconditions:
;;;   pred? can be applied to each value in lsts.
;;; Postconditions:
;;;   Every element of selected appears in lst and in the same order.
;;;   If (pred? (list-ref lst i)) holds for some value in
;;;     lst, then (list-ref lst i) appears in filtered.
(define/contract list-select
  (-> list? (-> any/c boolean?) list?)
  (lambda (lst pred?)
    (cond
      ((null? lst)
       null)
      ((pred? (car lst))
       (cons (car lst) (list-select (cdr lst) pred?)))
      (else
       (list-select (cdr lst) pred?)))))

; [From iascm/list/list-take.scm]

;;; Procedure:
;;;   list-take
;;; Parameters:
;;;   lst, a list
;;;   n, a non-negative integer
;;; Purpose:
;;;   Builds a new list consisting of the first n elements of lst.
;;; Produces:
;;;   newlst, a list
;;; Preconditions:
;;;   (length lst) >= n
;;; Postconditions:
;;;   (length newlst) = n
;;;   For each i, 0 <= i < n
;;;     (list-ref newlst i) = (list-ref lst i)
(define/contract list-take
  (-> list? (and/c integer? positive?) list?)
  (lambda (lst n)
    (cond
      ((zero? n)
       null)
      ((null? lst)
       null)
      (else
       (cons (car lst) (list-take (cdr lst) (- n 1)))))))

;(define list-take 
;  (lambda (lst n)
;    (cond
;      ((not (list? lst))
;       (error/parameter-type 'list-take 1 'list (list lst n)))
;      ((or (not (integer? n)) (negative? n))
;       (error/parameter-type 'list-take 2 'non-negative-integer (list lst n)))
;      ((< (length lst) n)
;       (error/parameter-type 'list-take 1 'list-of-length-at-least-n (list lst n)))
;      (else
;       (_list-take lst n)))))



